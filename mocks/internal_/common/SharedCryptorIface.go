// Code generated by mockery v2.52.2. DO NOT EDIT.

package common

import (
	jwt "github.com/golang-jwt/jwt/v5"
	common "github.com/luckyAkbar/atec/internal/common"

	mock "github.com/stretchr/testify/mock"
)

// SharedCryptorIface is an autogenerated mock type for the SharedCryptorIface type
type SharedCryptorIface struct {
	mock.Mock
}

type SharedCryptorIface_Expecter struct {
	mock *mock.Mock
}

func (_m *SharedCryptorIface) EXPECT() *SharedCryptorIface_Expecter {
	return &SharedCryptorIface_Expecter{mock: &_m.Mock}
}

// CompareHash provides a mock function with given fields: hashed, plain
func (_m *SharedCryptorIface) CompareHash(hashed []byte, plain []byte) error {
	ret := _m.Called(hashed, plain)

	if len(ret) == 0 {
		panic("no return value specified for CompareHash")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) error); ok {
		r0 = rf(hashed, plain)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SharedCryptorIface_CompareHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompareHash'
type SharedCryptorIface_CompareHash_Call struct {
	*mock.Call
}

// CompareHash is a helper method to define mock.On call
//   - hashed []byte
//   - plain []byte
func (_e *SharedCryptorIface_Expecter) CompareHash(hashed interface{}, plain interface{}) *SharedCryptorIface_CompareHash_Call {
	return &SharedCryptorIface_CompareHash_Call{Call: _e.mock.On("CompareHash", hashed, plain)}
}

func (_c *SharedCryptorIface_CompareHash_Call) Run(run func(hashed []byte, plain []byte)) *SharedCryptorIface_CompareHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].([]byte))
	})
	return _c
}

func (_c *SharedCryptorIface_CompareHash_Call) Return(_a0 error) *SharedCryptorIface_CompareHash_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SharedCryptorIface_CompareHash_Call) RunAndReturn(run func([]byte, []byte) error) *SharedCryptorIface_CompareHash_Call {
	_c.Call.Return(run)
	return _c
}

// CreateJWT provides a mock function with given fields: claims
func (_m *SharedCryptorIface) CreateJWT(claims jwt.Claims) (string, error) {
	ret := _m.Called(claims)

	if len(ret) == 0 {
		panic("no return value specified for CreateJWT")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(jwt.Claims) (string, error)); ok {
		return rf(claims)
	}
	if rf, ok := ret.Get(0).(func(jwt.Claims) string); ok {
		r0 = rf(claims)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(jwt.Claims) error); ok {
		r1 = rf(claims)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SharedCryptorIface_CreateJWT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateJWT'
type SharedCryptorIface_CreateJWT_Call struct {
	*mock.Call
}

// CreateJWT is a helper method to define mock.On call
//   - claims jwt.Claims
func (_e *SharedCryptorIface_Expecter) CreateJWT(claims interface{}) *SharedCryptorIface_CreateJWT_Call {
	return &SharedCryptorIface_CreateJWT_Call{Call: _e.mock.On("CreateJWT", claims)}
}

func (_c *SharedCryptorIface_CreateJWT_Call) Run(run func(claims jwt.Claims)) *SharedCryptorIface_CreateJWT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(jwt.Claims))
	})
	return _c
}

func (_c *SharedCryptorIface_CreateJWT_Call) Return(_a0 string, _a1 error) *SharedCryptorIface_CreateJWT_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SharedCryptorIface_CreateJWT_Call) RunAndReturn(run func(jwt.Claims) (string, error)) *SharedCryptorIface_CreateJWT_Call {
	_c.Call.Return(run)
	return _c
}

// Decrypt provides a mock function with given fields: cipherText
func (_m *SharedCryptorIface) Decrypt(cipherText string) (string, error) {
	ret := _m.Called(cipherText)

	if len(ret) == 0 {
		panic("no return value specified for Decrypt")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(cipherText)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(cipherText)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(cipherText)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SharedCryptorIface_Decrypt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decrypt'
type SharedCryptorIface_Decrypt_Call struct {
	*mock.Call
}

// Decrypt is a helper method to define mock.On call
//   - cipherText string
func (_e *SharedCryptorIface_Expecter) Decrypt(cipherText interface{}) *SharedCryptorIface_Decrypt_Call {
	return &SharedCryptorIface_Decrypt_Call{Call: _e.mock.On("Decrypt", cipherText)}
}

func (_c *SharedCryptorIface_Decrypt_Call) Run(run func(cipherText string)) *SharedCryptorIface_Decrypt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *SharedCryptorIface_Decrypt_Call) Return(_a0 string, _a1 error) *SharedCryptorIface_Decrypt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SharedCryptorIface_Decrypt_Call) RunAndReturn(run func(string) (string, error)) *SharedCryptorIface_Decrypt_Call {
	_c.Call.Return(run)
	return _c
}

// Encrypt provides a mock function with given fields: plainText
func (_m *SharedCryptorIface) Encrypt(plainText string) (string, error) {
	ret := _m.Called(plainText)

	if len(ret) == 0 {
		panic("no return value specified for Encrypt")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(plainText)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(plainText)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(plainText)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SharedCryptorIface_Encrypt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Encrypt'
type SharedCryptorIface_Encrypt_Call struct {
	*mock.Call
}

// Encrypt is a helper method to define mock.On call
//   - plainText string
func (_e *SharedCryptorIface_Expecter) Encrypt(plainText interface{}) *SharedCryptorIface_Encrypt_Call {
	return &SharedCryptorIface_Encrypt_Call{Call: _e.mock.On("Encrypt", plainText)}
}

func (_c *SharedCryptorIface_Encrypt_Call) Run(run func(plainText string)) *SharedCryptorIface_Encrypt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *SharedCryptorIface_Encrypt_Call) Return(_a0 string, _a1 error) *SharedCryptorIface_Encrypt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SharedCryptorIface_Encrypt_Call) RunAndReturn(run func(string) (string, error)) *SharedCryptorIface_Encrypt_Call {
	_c.Call.Return(run)
	return _c
}

// Hash provides a mock function with given fields: data
func (_m *SharedCryptorIface) Hash(data []byte) (string, error) {
	ret := _m.Called(data)

	if len(ret) == 0 {
		panic("no return value specified for Hash")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) (string, error)); ok {
		return rf(data)
	}
	if rf, ok := ret.Get(0).(func([]byte) string); ok {
		r0 = rf(data)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SharedCryptorIface_Hash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Hash'
type SharedCryptorIface_Hash_Call struct {
	*mock.Call
}

// Hash is a helper method to define mock.On call
//   - data []byte
func (_e *SharedCryptorIface_Expecter) Hash(data interface{}) *SharedCryptorIface_Hash_Call {
	return &SharedCryptorIface_Hash_Call{Call: _e.mock.On("Hash", data)}
}

func (_c *SharedCryptorIface_Hash_Call) Run(run func(data []byte)) *SharedCryptorIface_Hash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *SharedCryptorIface_Hash_Call) Return(_a0 string, _a1 error) *SharedCryptorIface_Hash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SharedCryptorIface_Hash_Call) RunAndReturn(run func([]byte) (string, error)) *SharedCryptorIface_Hash_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateJWT provides a mock function with given fields: token, opts
func (_m *SharedCryptorIface) ValidateJWT(token string, opts common.ValidateJWTOpts) (*jwt.Token, error) {
	ret := _m.Called(token, opts)

	if len(ret) == 0 {
		panic("no return value specified for ValidateJWT")
	}

	var r0 *jwt.Token
	var r1 error
	if rf, ok := ret.Get(0).(func(string, common.ValidateJWTOpts) (*jwt.Token, error)); ok {
		return rf(token, opts)
	}
	if rf, ok := ret.Get(0).(func(string, common.ValidateJWTOpts) *jwt.Token); ok {
		r0 = rf(token, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jwt.Token)
		}
	}

	if rf, ok := ret.Get(1).(func(string, common.ValidateJWTOpts) error); ok {
		r1 = rf(token, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SharedCryptorIface_ValidateJWT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateJWT'
type SharedCryptorIface_ValidateJWT_Call struct {
	*mock.Call
}

// ValidateJWT is a helper method to define mock.On call
//   - token string
//   - opts common.ValidateJWTOpts
func (_e *SharedCryptorIface_Expecter) ValidateJWT(token interface{}, opts interface{}) *SharedCryptorIface_ValidateJWT_Call {
	return &SharedCryptorIface_ValidateJWT_Call{Call: _e.mock.On("ValidateJWT", token, opts)}
}

func (_c *SharedCryptorIface_ValidateJWT_Call) Run(run func(token string, opts common.ValidateJWTOpts)) *SharedCryptorIface_ValidateJWT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(common.ValidateJWTOpts))
	})
	return _c
}

func (_c *SharedCryptorIface_ValidateJWT_Call) Return(_a0 *jwt.Token, _a1 error) *SharedCryptorIface_ValidateJWT_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SharedCryptorIface_ValidateJWT_Call) RunAndReturn(run func(string, common.ValidateJWTOpts) (*jwt.Token, error)) *SharedCryptorIface_ValidateJWT_Call {
	_c.Call.Return(run)
	return _c
}

// NewSharedCryptorIface creates a new instance of SharedCryptorIface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSharedCryptorIface(t interface {
	mock.TestingT
	Cleanup(func())
}) *SharedCryptorIface {
	mock := &SharedCryptorIface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
